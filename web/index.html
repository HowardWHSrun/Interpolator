<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Offline Interpolator (HTML + JS)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;margin:0;padding:24px;line-height:1.45;background:#f7fafc;color:#0f172a}
    h1{font-size:20px;margin:0 0 12px}
    .card{background:#fff;border:1px solid #e2e8f0;border-radius:10px;max-width:980px;padding:18px;margin:0 auto 16px;box-shadow:0 2px 6px rgba(0,0,0,0.04)}
    label{display:block;font-weight:600;margin-bottom:6px}
    input[type=file],select,button{font:inherit}
    input[type=file]{border:1px dashed #94a3b8;padding:16px;width:100%;border-radius:8px;background:#f8fafc}
    select{padding:10px;border-radius:8px;border:1px solid #cbd5e1;background:#fff;min-width:300px}
    button{background:#0ea5e9;color:white;border:none;border-radius:8px;padding:10px 14px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.6;cursor:not-allowed}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .muted{color:#64748b}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .spacer{height:8px}
    .hidden{display:none}
    .log{white-space:pre-wrap;font-size:13px;background:#0f172a;color:#e2e8f0;padding:12px;border-radius:8px;max-height:260px;overflow:auto}
  </style>
</head>
<body>
  <div class="card">
    <h1>Offline Interpolator (HTML + JS)</h1>
    <p class="muted">Works entirely in your browser. Upload CSV with columns <span class="mono">timestamp</span>, <span class="mono">dist_from_start</span> (ft), <span class="mono">speed</span> (m/s). Optional: <span class="mono">trip_id</span>.</p>
  </div>

  <div class="card">
    <label for="csvFile">Upload CSV</label>
    <input id="csvFile" type="file" accept=".csv" />
    <div class="spacer"></div>
    <div id="uploadStatus" class="muted">No file selected.</div>
  </div>

  <div class="card">
    <div class="row">
      <div>
        <label for="tripSelect">Select trip (if CSV has trip_id)</label>
        <select id="tripSelect" disabled></select>
      </div>
      <div>
        <label>&nbsp;</label>
        <button id="runBtn" disabled>Interpolate</button>
      </div>
    </div>
    <div class="spacer"></div>
    <div id="tripCount" class="muted"></div>
  </div>

  <div class="card">
    <label>Activity</label>
    <div id="log" class="log">Ready.</div>
  </div>

  <div class="card">
    <label>Results</label>
    <div class="muted">Distance vs Time (ft, s) and Velocity vs Time (mph, s)</div>
    <div class="spacer"></div>
    <div class="row" style="gap:16px; align-items:flex-start;">
      <div style="flex:1 1 460px; min-width:320px;">
        <canvas id="chartDist" style="width:100%; height:320px; background:#fff; border:1px solid #e2e8f0; border-radius:8px;"></canvas>
      </div>
      <div style="flex:1 1 460px; min-width:320px;">
        <canvas id="chartVel" style="width:100%; height:320px; background:#fff; border:1px solid #e2e8f0; border-radius:8px;"></canvas>
      </div>
    </div>
  </div>

  <script>
    const csvFile = document.getElementById('csvFile')
    const uploadStatus = document.getElementById('uploadStatus')
    const tripSelect = document.getElementById('tripSelect')
    const tripCount = document.getElementById('tripCount')
    const runBtn = document.getElementById('runBtn')
    const chartDist = document.getElementById('chartDist')
    const chartVel = document.getElementById('chartVel')
    const logEl = document.getElementById('log')

    let rows = []
    let headers = []
    let tripIds = []
    const MPH_TO_FPS = 1.46667
    const MPS_TO_FPS = 3.28084
    const MPS_TO_MPH = 2.2369362921
    const MAX_SPEED_MPH = 60.0
    const V_FPS = MAX_SPEED_MPH * MPH_TO_FPS

    function log(msg){
      const time = new Date().toLocaleTimeString()
      logEl.textContent += `\n[${time}] ${msg}`
      logEl.scrollTop = logEl.scrollHeight
    }

    function parseCSV(text){
      const out = []
      let i=0, field='', record=[], inQuotes=false
      function pushField(){ record.push(field); field='' }
      function pushRecord(){ if(record.length){ out.push(record); record=[] } }
      while(i < text.length){
        const ch = text[i]
        if(inQuotes){
          if(ch === '"'){
            if(text[i+1] === '"'){ field += '"'; i += 2; continue } else { inQuotes = false; i++; continue }
          } else { field += ch; i++; continue }
        } else {
          if(ch === '"'){ inQuotes = true; i++; continue }
          if(ch === ','){ pushField(); i++; continue }
          if(ch === '\n' || ch === '\r'){ pushField(); pushRecord();
            // consume \r\n
            if(ch==='\r' && text[i+1]==='\n'){ i+=2 } else { i++ }
            continue }
          field += ch; i++
        }
      }
      // last field/record
      pushField(); pushRecord()
      // drop trailing empty lines
      while(out.length && out[out.length-1].every(x=>x==='')) out.pop()
      return out
    }

    function csvToObjects(matrix){
      if(!matrix.length) return { headers: [], rows: [] }
      const hdr = matrix[0].map(h=>h.trim())
      const data = matrix.slice(1).map(r => {
        const obj = {}
        hdr.forEach((h, idx) => { obj[h] = r[idx] })
        return obj
      })
      return { headers: hdr, rows: data }
    }

    function toNumber(v){
      const n = Number(v)
      return Number.isFinite(n) ? n : NaN
    }

    function toDate(v){
      // accepts ISO-like strings
      const d = new Date(v)
      if(!isNaN(d.getTime())) return d
      // try as epoch seconds
      const s = Number(v)
      if(Number.isFinite(s)) return new Date(s*1000)
      return null
    }

    function ensureColumns(rs){
      const need = ['timestamp','dist_from_start','speed']
      const missing = need.filter(k => !(k in rs[0]))
      if(missing.length){ throw new Error('CSV missing columns: ' + missing.join(', ')) }
    }

    function preprocess(rs){
      // returns a new array sorted by timestamp with time_seconds and speed_fps
      const mapped = []
      for(const r of rs){
        const d = toDate(r.timestamp)
        const dist = toNumber(r.dist_from_start)
        const spd_ms = toNumber(r.speed)
        if(!d || !Number.isFinite(dist) || !Number.isFinite(spd_ms)) continue
        mapped.push({
          timestamp: d,
          dist_from_start: dist,
          speed_ms: spd_ms,
          speed_fps: spd_ms * MPS_TO_FPS,
          trip_id: r.trip_id ?? null
        })
      }
      mapped.sort((a,b)=>a.timestamp - b.timestamp)
      if(!mapped.length) throw new Error('No valid rows after parsing.')
      const t0 = mapped[0].timestamp.getTime()/1000
      for(const m of mapped){ m.time_seconds = (m.timestamp.getTime()/1000) - t0 }
      return mapped
    }

    function integrateTrapezoid(times, values, x0){
      const x = new Array(times.length)
      x[0] = x0
      for(let i=1;i<times.length;i++){
        const dt = times[i] - times[i-1]
        x[i] = x[i-1] + 0.5 * (values[i-1] + values[i]) * dt
      }
      return x
    }

    // ---------------- Trip-wide local minimum-jerk (2% tol) -----------------
    function interpToGrid(srcX, srcY, dstX){
      const out = new Array(dstX.length)
      let j = 0
      for(let i=0;i<dstX.length;i++){
        const x = dstX[i]
        while(j+1 < srcX.length && srcX[j+1] <= x) j++
        if(j+1 >= srcX.length){ out[i] = srcY[srcY.length-1]; continue }
        const x0 = srcX[j], x1 = srcX[j+1]
        const y0 = srcY[j], y1 = srcY[j+1]
        const u = x1 > x0 ? (x - x0)/(x1 - x0) : 0
        out[i] = y0 + (y1 - y0) * Math.min(Math.max(u,0),1)
      }
      return out
    }

    function movingAverage(arr, k){
      if(k<=1) return arr.slice()
      const n = arr.length
      const half = Math.floor(k/2)
      const out = new Array(n)
      const pref = new Array(n+1)
      pref[0] = 0
      for(let i=0;i<n;i++) pref[i+1] = pref[i] + arr[i]
      for(let i=0;i<n;i++){
        const a = Math.max(0, i-half)
        const b = Math.min(n-1, i+half)
        const s = pref[b+1] - pref[a]
        out[i] = s / (b - a + 1)
      }
      return out
    }

    function slopeCap(v, dt, a_ms2, b_ms2){
      const n = v.length
      const out = v.slice()
      // accel cap forward
      for(let i=1;i<n;i++){
        out[i] = Math.min(out[i], out[i-1] + a_ms2 * dt)
      }
      // decel cap backward (use b for brake)
      for(let i=n-2;i>=0;i--){
        out[i] = Math.min(out[i], out[i+1] + b_ms2 * dt)
      }
      for(let i=0;i<n;i++) out[i] = Math.min(Math.max(out[i], 0.0), MAX_SPEED_MPH * 0.44704)
      return out
    }

    function calculateLocalMinJerkTrip(pre, distanceTolFrac=0.02){
      if(pre.length < 2) return null
      // Build measurement arrays
      const mt = pre.map(p=>p.time_seconds)
      const mx_m = pre.map(p=>p.dist_from_start * 0.3048)
      const mv_ms = pre.map(p=>p.speed_ms)
      const t0 = Math.min(...mt), t1 = Math.max(...mt)
      if(!(t1 > t0) || !isFinite(t1) || !isFinite(t0)) return null
      const duration = t1 - t0
      const step = Math.max(1.0, duration/800.0)
      const N = Math.min(1600, Math.max(300, Math.round(duration/step)))
      const tg = new Array(N)
      for(let i=0;i<N;i++) tg[i] = t0 + (duration * i)/(N-1)
      const dt = duration / Math.max(1, N-1)
      const sgn = (mx_m[mx_m.length-1] >= mx_m[0]) ? 1.0 : -1.0
      const vmax_ms = MAX_SPEED_MPH * 0.44704
      let v = interpToGrid(mt, mv_ms, tg).map(x => Math.min(Math.max(x, 0.0), vmax_ms))
      const span_m = Math.max(1e-6, Math.abs(mx_m[mx_m.length-1] - mx_m[0]))
      const dist_tol = distanceTolFrac * span_m
      const speed_tol = 0.5
      const a_ms2 = 1.3
      const b_ms2 = 2.2
      const zero_lock_eps = 0.15

      // Iterative smoothing + measurement blending + accel caps + area correction
      for(let iter=0; iter<6; iter++){
        // Smooth (increase window slightly across iterations)
        const win = Math.max(7, ((Math.floor(N/50)|0)*2 + 1))
        v = movingAverage(v, win)
        // Blend towards measurements (robust, only beyond tolerance)
        const v_at_meas = interpToGrid(tg, v, mt)
        const corr = new Array(mt.length)
        for(let i=0;i<mt.length;i++){
          const diff = v_at_meas[i] - mv_ms[i]
          const sign = diff >= 0 ? 1 : -1
          const mag = Math.max(0, Math.abs(diff) - speed_tol)
          corr[i] = -0.25 * sign * mag
        }
        const corr_grid = interpToGrid(mt, corr, tg)
        for(let i=0;i<N;i++) v[i] = Math.min(Math.max(v[i] + corr_grid[i], 0.0), vmax_ms)
        // Zero locks
        for(let i=0;i<mt.length;i++){
          if(mv_ms[i] <= zero_lock_eps){
            // push nearest grid value closer to zero
            const t = mt[i]
            const idx = Math.min(N-1, Math.max(0, Math.round((t - t0)/dt)))
            v[idx] = Math.min(v[idx], 0.05)
          }
        }
        // Acceleration caps
        v = slopeCap(v, dt, a_ms2, b_ms2)
        // Area correction to match trip distance within tolerance
        let x = new Array(N)
        x[0] = mx_m[0]
        for(let i=1;i<N;i++) x[i] = x[i-1] + sgn * 0.5 * (v[i-1] + v[i]) * dt
        const err = (mx_m[mx_m.length-1] - x[N-1])
        const adjust = sgn * (err / Math.max(1e-6, duration))
        for(let i=0;i<N;i++) v[i] = Math.min(Math.max(v[i] + adjust, 0.0), vmax_ms)
        v = slopeCap(v, dt, a_ms2, b_ms2)
      }
      // Final integrate
      const x_m = new Array(N)
      x_m[0] = mx_m[0]
      for(let i=1;i<N;i++) x_m[i] = x_m[i-1] + sgn * 0.5 * (v[i-1] + v[i]) * dt
      const x_ft = x_m.map(d=>d/0.3048)
      return { tg, x_ft, v_ms: v }
    }

    // ---------------- Per-segment (kept for reference, not used now) ---------
    function calculateLinearVelocitySegment(t1, t2, d1, d2, v1_fps, v2_fps, num_points=120){
      const T = t2 - t1
      if(!(T>0)) return null
      const sgn = d2 >= d1 ? 1.0 : -1.0
      const t = new Array(num_points)
      const tau = new Array(num_points)
      for(let i=0;i<num_points;i++){ t[i] = t1 + (T * i)/(num_points-1); tau[i] = t[i] - t1 }
      const v1_mag = Math.max(v1_fps, 0.0)
      const v2_mag = Math.max(v2_fps, 0.0)
      const u = tau.map(tt => tt / T)
      const v_base_mag = u.map(uu => v1_mag + (v2_mag - v1_mag) * uu)

      function g(uu){ return 6.0 * uu * (1.0 - uu) }
      const gArr = u.map(g)

      function integrateWithA(a){
        const v_mag = v_base_mag.map((vb,i)=>Math.min(Math.max(vb + a * gArr[i], 0.0), V_FPS))
        const v_signed = v_mag.map(vm => sgn * vm)
        const x = integrateTrapezoid(tau, v_signed, d1)
        return { v_mag, v_signed, x }
      }

      function f(a){
        const { x } = integrateWithA(a)
        return x[x.length-1] - d2
      }

      // Bracket root
      let a_lo = -V_FPS, a_hi = V_FPS
      let f_lo = f(a_lo), f_hi = f(a_hi)
      let tries = 0
      while(f_lo * f_hi > 0 && tries < 40){
        if(Math.abs(f_lo) < Math.abs(f_hi)){
          a_hi *= 1.7
          f_hi = f(a_hi)
        } else {
          a_lo *= 1.7
          f_lo = f(a_lo)
        }
        tries++
      }

      let v_signed, x_like
      if(f_lo * f_hi > 0){
        // coarse grid fallback
        const gridN = 41
        let bestA = a_lo, bestE = Infinity
        for(let i=0;i<gridN;i++){
          const a = a_lo + (i/(gridN-1))*(a_hi - a_lo)
          const e = Math.abs(f(a))
          if(e < bestE){ bestE = e; bestA = a }
        }
        const res = integrateWithA(bestA)
        v_signed = res.v_signed; x_like = res.x
      } else {
        // bisection
        for(let k=0;k<60;k++){
          const a_mid = 0.5*(a_lo + a_hi)
          const f_mid = f(a_mid)
          if(Math.abs(f_mid) <= 1e-4){ a_lo = a_hi = a_mid; break }
          if(f_lo * f_mid <= 0){ a_hi = a_mid; f_hi = f_mid } else { a_lo = a_mid; f_lo = f_mid }
        }
        const a_star = 0.5*(a_lo + a_hi)
        const res = integrateWithA(a_star)
        v_signed = res.v_signed; x_like = res.x
      }

      const v_mph = v_signed.map(v => Math.abs(v) / MPH_TO_FPS)
      return {
        time: t,
        min_speed: v_mph,
        max_speed: v_mph,
        likely_speed: v_mph,
        min_position: x_like,
        max_position: x_like,
        likely_position: x_like
      }
    }

    // mergeSegments no longer used in minimal-jerk flow

    function toCSV(headers, data){
      const esc = v => {
        const s = String(v ?? '')
        if(s.includes('"') || s.includes(',') || s.includes('\n')) return '"' + s.replaceAll('"','""') + '"'
        return s
      }
      let lines = [headers.join(',')]
      for(const r of data){ lines.push(headers.map(h=>esc(r[h])).join(',')) }
      return lines.join('\n')
    }

    function setBusy(b){
      csvFile.disabled = b
      tripSelect.disabled = b || (tripIds.length>0 ? false : true)
      runBtn.disabled = b || !rows.length
    }

    csvFile.addEventListener('change', () => {
      const f = csvFile.files && csvFile.files[0]
      if(!f){ uploadStatus.textContent = 'No file selected.'; return }
      uploadStatus.textContent = `Reading ${f.name}…`
      const fr = new FileReader()
      fr.onload = () => {
        try{
          const matrix = parseCSV(String(fr.result||''))
          const { headers: hdr, rows: data } = csvToObjects(matrix)
          if(!data.length){ throw new Error('Empty CSV') }
          ensureColumns(data)
          headers = hdr
          rows = data
          // build trip IDs if present
          if(headers.includes('trip_id')){
            const set = new Set()
            for(const r of rows){ if(r.trip_id!=null && r.trip_id!=='' ) set.add(String(r.trip_id)) }
            tripIds = Array.from(set)
          } else { tripIds = [] }
          // populate UI
          tripSelect.innerHTML = ''
          if(tripIds.length){
            for(const tid of tripIds){
              const opt = document.createElement('option')
              opt.value = tid; opt.textContent = tid
              tripSelect.appendChild(opt)
            }
            tripSelect.disabled = false
            tripCount.textContent = `${tripIds.length} trip_id values detected.`
          } else {
            const opt = document.createElement('option')
            opt.value = ''; opt.textContent = '(No trip_id column — use whole file)'
            tripSelect.appendChild(opt)
            tripSelect.disabled = true
            tripCount.textContent = `No trip_id column found.`
          }
          runBtn.disabled = false
          uploadStatus.textContent = `Loaded ${rows.length} rows. Ready.`
          log('CSV loaded. Choose a trip (if available) then click Interpolate.')
        }catch(err){
          rows = []; headers = []; tripIds = []
          tripSelect.innerHTML = ''
          runBtn.disabled = true
          uploadStatus.textContent = 'Failed to parse CSV.'
          log('Error: ' + (err && err.message ? err.message : String(err)))
        }
      }
      fr.onerror = () => { uploadStatus.textContent = 'Failed to read file.' }
      fr.readAsText(f)
    })

    // ----------------------------- Drawing utils -----------------------------
    function setupHiDPICanvas(canvas){
      const dpr = window.devicePixelRatio || 1
      const rect = canvas.getBoundingClientRect()
      const w = Math.max(320, Math.floor(rect.width))
      const h = Math.max(220, Math.floor(rect.height))
      canvas.width = Math.floor(w * dpr)
      canvas.height = Math.floor(h * dpr)
      const ctx = canvas.getContext('2d')
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
      return { ctx, width: w, height: h }
    }

    function niceTicks(min, max, count=5){
      const span = max - min
      if(!(span>0) || !isFinite(span)) return { ticks:[min, max], min, max }
      const step0 = span / Math.max(1, count)
      const mag = Math.pow(10, Math.floor(Math.log10(step0)))
      const norm = step0 / mag
      let step
      if(norm < 1.5) step = 1*mag
      else if(norm < 3) step = 2*mag
      else if(norm < 7) step = 5*mag
      else step = 10*mag
      const lo = Math.floor(min/step)*step
      const hi = Math.ceil(max/step)*step
      const ticks = []
      for(let v=lo; v<=hi+1e-9; v+=step) ticks.push(v)
      return { ticks, min: lo, max: hi }
    }

    function drawChart(canvas, x, y, points, opts){
      const { ctx, width, height } = setupHiDPICanvas(canvas)
      ctx.clearRect(0,0,width,height)
      const m = { l: 54, r: 20, t: 12, b: 42 }
      const dataXMin = Math.min(...x), dataXMax = Math.max(...x)
      const dataYMin0 = Math.min(...y), dataYMax0 = Math.max(...y)
      const xMin = (opts && opts.xMin != null) ? opts.xMin : dataXMin
      const xMax = (opts && opts.xMax != null) ? opts.xMax : dataXMax
      const baseYMin = (opts && opts.yMin != null) ? opts.yMin : dataYMin0
      const baseYMax = (opts && opts.yMax != null) ? opts.yMax : dataYMax0
      const padY = (baseYMax - baseYMin) * 0.05
      const yMin = baseYMin - padY
      const yMax = baseYMax + padY
      const xt = niceTicks(xMin, xMax, 5)
      const yt = niceTicks(yMin, yMax, 5)
      const xmap = v => m.l + (v - xt.min)/(xt.max - xt.min) * (width - m.l - m.r)
      const ymap = v => height - m.b - (v - yt.min)/(yt.max - yt.min) * (height - m.t - m.b)
      // axes
      ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 1
      ctx.beginPath();
      ctx.moveTo(m.l, m.t); ctx.lineTo(m.l, height - m.b); ctx.lineTo(width - m.r, height - m.b)
      ctx.stroke()
      ctx.fillStyle = '#0f172a'; ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Inter'
      // ticks
      ctx.textAlign = 'center'; ctx.textBaseline = 'top'
      for(const v of xt.ticks){
        const px = xmap(v)
        ctx.strokeStyle = '#e2e8f0'
        ctx.beginPath(); ctx.moveTo(px, m.t); ctx.lineTo(px, height - m.b); ctx.stroke()
        ctx.fillStyle = '#475569'
        ctx.fillText(String(Math.round(v*10)/10), px, height - m.b + 6)
      }
      ctx.textAlign = 'right'; ctx.textBaseline = 'middle'
      for(const v of yt.ticks){
        const py = ymap(v)
        ctx.strokeStyle = '#e2e8f0'
        ctx.beginPath(); ctx.moveTo(m.l, py); ctx.lineTo(width - m.r, py); ctx.stroke()
        ctx.fillStyle = '#475569'
        ctx.fillText(String(Math.round(v*10)/10), m.l - 6, py)
      }
      // labels
      ctx.fillStyle = '#0f172a'; ctx.textAlign = 'center'; ctx.textBaseline = 'top'
      ctx.fillText(opts.xLabel || 'Time (s)', (m.l + width - m.r)/2, height - m.b + 22)
      ctx.save(); ctx.translate(10, (m.t + height - m.b)/2); ctx.rotate(-Math.PI/2)
      ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; ctx.fillText(opts.yLabel || '', 0, 0); ctx.restore()
      // line
      ctx.strokeStyle = '#0f172a'; ctx.lineWidth = 1.6
      ctx.beginPath()
      for(let i=0;i<x.length;i++){
        const px = xmap(x[i]); const py = ymap(y[i])
        if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py)
      }
      ctx.stroke()
      // points (original)
      if(points && points.x && points.y && points.x.length){
        ctx.fillStyle = '#ef4444';
        for(let i=0;i<points.x.length;i++){
          const px = xmap(points.x[i]); const py = ymap(points.y[i])
          ctx.beginPath(); ctx.arc(px, py, 2.2, 0, Math.PI*2); ctx.fill()
        }
      }
      return { xMin: xt.min, xMax: xt.max, yMin: yt.min, yMax: yt.max, xmap, ymap, width, height, margins: m }
    }

    // --------------------- Chart interactions: zoom / pan ---------------------
    function makeInteractive(canvas, data, labels){
      const state = {
        canvas,
        data, // { x, y, points }
        labels,
        view: { xMin: null, xMax: null, yMin: null, yMax: null },
        lastDraw: null,
      }
      function redraw(){
        state.lastDraw = drawChart(canvas, state.data.x, state.data.y, state.data.points, {
          xMin: state.view.xMin, xMax: state.view.xMax, yMin: state.view.yMin, yMax: state.view.yMax,
          xLabel: labels.xLabel, yLabel: labels.yLabel
        })
      }
      function reset(){ state.view = { xMin: null, xMax: null, yMin: null, yMax: null }; redraw() }
      let isPanning = false, panStart = null, startView = null
      function dataFromPixel(px, py){
        const d = state.lastDraw
        const { margins: m } = d
        const x = (px - m.l) / (d.width - m.l - m.r) * (d.xMax - d.xMin) + d.xMin
        const y = (d.height - m.b - py) / (d.height - m.t - m.b) * (d.yMax - d.yMin) + d.yMin
        return { x, y }
      }
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault()
        if(!state.lastDraw) return
        const rect = canvas.getBoundingClientRect()
        const px = e.clientX - rect.left
        const py = e.clientY - rect.top
        const p = dataFromPixel(px, py)
        const zx = Math.exp(-e.deltaY * 0.001)
        const zy = e.shiftKey ? 1 : zx
        const cur = state.lastDraw
        const xMin = cur.xMin + (p.x - cur.xMin) * (1 - zx)
        const xMax = cur.xMax - (cur.xMax - p.x) * (1 - zx)
        const yMin = cur.yMin + (p.y - cur.yMin) * (1 - zy)
        const yMax = cur.yMax - (cur.yMax - p.y) * (1 - zy)
        state.view = { xMin, xMax, yMin, yMax }
        redraw()
      }, { passive:false })
      canvas.addEventListener('mousedown', (e) => {
        if(!state.lastDraw) return
        isPanning = true
        const rect = canvas.getBoundingClientRect()
        panStart = { x: e.clientX - rect.left, y: e.clientY - rect.top }
        startView = { ...state.lastDraw }
      })
      window.addEventListener('mousemove', (e) => {
        if(!isPanning || !state.lastDraw) return
        const rect = canvas.getBoundingClientRect()
        const dx = (e.clientX - rect.left) - panStart.x
        const dy = (e.clientY - rect.top) - panStart.y
        const d = state.lastDraw
        const { margins: m } = d
        const xRange = (startView.xMax - startView.xMin)
        const yRange = (startView.yMax - startView.yMin)
        const xShift = dx / (d.width - m.l - m.r) * xRange
        const yShift = -dy / (d.height - m.t - m.b) * yRange
        state.view = { xMin: startView.xMin - xShift, xMax: startView.xMax - xShift, yMin: startView.yMin - yShift, yMax: startView.yMax - yShift }
        redraw()
      })
      window.addEventListener('mouseup', () => { isPanning = false })
      canvas.addEventListener('mouseleave', () => { isPanning = false })
      canvas.addEventListener('dblclick', () => reset())
      // initial draw
      redraw()
      return { setData: (x,y,points) => { state.data = { x, y, points }; reset() }, reset }
    }

    runBtn.addEventListener('click', () => {
      if(!rows.length) return
      setBusy(true)
      try{
        // Filter by selected trip if present
        let work = rows
        const sel = tripIds.length ? tripSelect.value : ''
        if(tripIds.length && sel){ work = rows.filter(r => String(r.trip_id)===sel) }
        const pre = preprocess(work)
        if(pre.length < 2) throw new Error('Not enough points after filtering')
        log(`Interpolating ${pre.length} points…`)
        const lmj = calculateLocalMinJerkTrip(pre, 0.02)
        if(!lmj) throw new Error('Optimizer failed')
        const t = lmj.tg
        // Optional light smoothing for plotting stability (does not change data fidelity)
        const pos = movingAverage(lmj.x_ft, 5)
        const vel = movingAverage(lmj.v_ms.map(v=>v * MPS_TO_MPH), 7)
        log(`Generated ${t.length} samples. Rendering charts…`)
        const tGps = pre.map(p=>p.time_seconds)
        const posGps = pre.map(p=>p.dist_from_start)
        const velGps = pre.map(p=>p.speed_ms * MPS_TO_MPH)
        const distChart = makeInteractive(chartDist, { x: t, y: pos, points: { x: tGps, y: posGps } }, { xLabel: 'Time (s)', yLabel: 'Distance (ft)' })
        const velChart  = makeInteractive(chartVel,  { x: t, y: vel, points: { x: tGps, y: velGps } }, { xLabel: 'Time (s)', yLabel: 'Velocity (mph)' })
        log('Done.')
      }catch(err){
        console.error(err)
        log('Error: ' + (err && err.message ? err.message : String(err)))
      }finally{
        setBusy(false)
      }
    })
  </script>
</body>
</html>


